# 수직선 점프 풀이
"""
Constraints의 각 x1, x2, v1, v2 가 각각 10^4 이므로 n^2의 시간복잡도를 가지는 풀이는 지양한다.
즉, 이중 for문은 사용 하지 않으며, nlogn, n, logn, 1의 시간 복잡도를 갖는 풀이 방식을 생각해 내야 한다.
또한 x1(캥거루 1의 시작 위치)보다 x2(캥거루 2의 시작 위치)가 커야 한다.

for문을 한 번만 사용한다. 단 반복 횟수를 알 수 없으니 while True: 무한 루프문으로 사용하고
No가 나오는 경우에도 적절한 타이밍에 끊어줘야 한다.
결국 점프 회수 i가 1씩 증가했을 때, 어느 시점에서 x1+(v1*i)와 x2+(v2*i)가 일치해야 한다.
일치 하지 않더라도 그것(최소공배수가 가능한지)을 확인할 방법이 있어야 한다.
x1보다 x2가 항상 큰 수를 가지므로, 캥거루2의 i 번째 점프 위치가 캥거루1의 i 번째 점프 위치로 나누어 떨어지는지 확인한다.
또한 v2가 v1보다 항상 작아야 캥거루 1이 캥거루 2를 따라잡을 수 있으므로 이 조건을 가장 처음 도입한다.
"""
def kangaroo(x1, v1, x2, v2) :
    if(v2>=v1):
        print("NO")
        return
    if(x2-x1)%(v1-v2)==0 :
         print("YES")
    else :
         print("NO")
    # i = 0
    # while True:
    #     k1 = x1+(v1*i)  # 캥거루 1의 i번째 위치
    #     k2 = x2+(v2*i)  # 캥거루 2의 i번째 위치
    #     i = i+1
    #
    #     if(k1 == k2):     # 같을 때 까지라고 한다면 언제까지 늘어날지 모른다. 10^8을 초과하는 것은 물론이거니와 처음 위치 차이에 따라 그런 수가 아예 존재하지 않을 수도 있다.
    #         print("YES" + str(i-1))
    #         return

kangaroo(0, 5, 3, 2)

"""
<GPT 찬스>
jumpA > jumpB인 경우
(posB - posA) % (jumpA - jumpB) == 0인 양의 정수 n이 존재해야 합니다.
처음 거리의 차이를 점프력 차이로 나누었을 때 나누어 떨어지는 양의 정수 n?

(posB - posA)와 (jumpA - jumpB)의 최대공약수를 구하는 것은, 유클리드 호제법을 적용한 것입니다. 
유클리드 호제법은 (서로소 여부를 판단해주는) 두 수의 최대공약수를 구하는 방법 중 하나로, 다음과 같은 원리에 기반합니다.
두 수 a, b가 주어졌을 때, a를 b로 나눈 나머지를 r이라고 하면, 
a와 b의 최대공약수는 b와 r의 최대공약수와 같습니다. 이를 수식으로 나타내면 다음과 같습니다:
gcd(a, b) = gcd(b, r)
이 원리를 반복적으로 적용하면, 최종적으로 r이 0이 되는 경우가 발생합니다. 이때, b가 a와 b의 최대공약수가 됩니다. 
따라서, 위에서 (posB - posA)와 (jumpA - jumpB)의 최대공약수를 구한 것은, 
유클리드 호제법을 적용한 것입니다. 이 최대공약수가 1보다 큰 경우, 캥거루 A와 B는 그 이후에도 같은 지점에서 만날 수 있습니다.
"""