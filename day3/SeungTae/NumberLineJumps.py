# 수직선 점프 풀이
"""
Constraints의 각 x1, x2, v1, v2 가 각각 10^4 이므로 n^2의 시간복잡도를 가지는 풀이는 지양한다.
즉, 이중 for문은 사용 하지 않으며, nlogn, n, logn, 1의 시간 복잡도를 갖는 풀이 방식을 생각해 내야 한다.
또한 x1(캥거루 1의 시작 위치)보다 x2(캥거루 2의 시작 위치)가 커야 한다.

for문을 한 번만 사용한다. 단 반복 횟수를 알 수 없으니 while True: 무한 루프문으로 사용하고
No가 나오는 경우에도 적절한 타이밍에 끊어줘야 한다.
결국 점프 회수 i가 1씩 증가했을 때, 어느 시점에서 x1+(v1*i)와 x2+(v2*i)가 일치해야 한다.
일치 하지 않더라도 그것(최소공배수가 가능한지)을 확인할 방법이 있어야 한다.
x1보다 x2가 항상 큰 수를 가지므로, 캥거루2의 i 번째 점프 위치가 캥거루1의 i 번째 점프 위치로 나누어 떨어지는지 확인한다.
또한 v2가 v1보다 항상 작아야 캥거루 1이 캥거루 2를 따라잡을 수 있으므로 이 조건을 가장 처음 도입한다.
"""
def kangaroo(x1, v1, x2, v2) :
    if(v2>=v1):
        print("NO")
        return
    if(x2-x1)%(v1-v2)==0 :
         print("YES")
    else :
         print("NO")
    # i = 0
    # while True:
    #     k1 = x1+(v1*i)  # 캥거루 1의 i번째 위치
    #     k2 = x2+(v2*i)  # 캥거루 2의 i번째 위치
    #     i = i+1
    #
    #     if(k1 == k2):     # 같을 때 까지라고 한다면 언제까지 늘어날지 모른다. 10^8을 초과하는 것은 물론이거니와 처음 위치 차이에 따라 그런 수가 아예 존재하지 않을 수도 있다.
    #         print("YES" + str(i-1))
    #         return

kangaroo(0, 5, 3, 2)

"""
<GPT 찬스>
jumpA > jumpB인 경우
(posB - posA) % (jumpA - jumpB) == 0인 양의 정수 n이 존재해야 합니다.
처음 거리의 차이를 점프력 차이로 나누었을 때 나누어 떨어지는 양의 정수 n?
"""